import java.util.*;
import java.io.*;

// 16942 : 문자열 접기

/*
-- 전제조건
상도가 문자열에 접기 연산을 실행하려고 한다.
접기 연산을 수행하려면 먼저 문자열을 접을 위치를 정해야 하고,
위치는 인접한 두 문자 사이이다.
이 위치를 기준으로 왼쪽 부분 A와 오른쪽 부분 B로 나뉜다.
다음 B를 뒤집고 , A의 위에 뒤집은 문자열 B를 놓는다.
A 와 B는 접은 위치를 기준으로 줄이 맞춰져 있어야 한다.

이럴 때 , 맨 아래에서부터 문자열의 개수를 세기 시작하였을 때 , 가장 긴 문자열의 개수를 출력하시오.(같은 문자로만 이루어져 있으면서)
문자열은 신경쓰지 않아도 되는 줄 알았는데 , 그것도 아니였음
-- 틀 설계
문제에 있는 예시들

ABCDEF|GHIJK

 KJIHG
ABCDEF

A|BCDEFGHIJK

KJIHGFEDCB
         A

AB|RACA|DAB|RA와 X|XXXXX|X|X|XXXXXX

           XXXXXX
 AR        X
DAB        X
ACAR       XXXXX
  AB           X

ABCD|EFGH|IJ|K

 K
IJ
HGFE
ABCD

X|XXXXX|X|X|XXXXXX
이것은 여기서 더 이상 만들 수 없다고 표현하고 있다.

XXXXXX
X
X
XXXXX
    X

A|BCDEFGHIJK

KJIHGFEDCB
         A

AB|RACA|DAB|RA

 AR
DAB
ACAR
  AB

여기서 만들 수 있는 것은 AABR 과 , BR 이 있다.
즉 맨 아래에서 부터 시작할 수 있다.

여기서 의미하는 것은 맨 아래에서 시작하지 않으면 의미가 없다는 것을 의미하고
맨 아래 문자열이 1 에서 부터 N - 1 개까지 존재할 때까지의 경우의 수가 존재하게 된다.

이것을 접었을 떄 , DP 적인 방법을 어떻게 하며 이용할 수 있을까?
일단 맨 아래로부터 똑같은 문자를 쌓아올릴 수 있다라는 보증을 받을 수 있어야 한다.

일단 해당 문자가 어디 컬럼에 있는지를 어떻게 정의할 수 있으며
문자열을 뒤집을 때의 과정이 필요하다.

문자열을 뒤집는 과정은 생각보다 간단하다.
그냥 문자열 그대로 읽어서 바로 위에서부터 거꾸로 채워넣으면 된다.

그리고 가장 기본적인 생각으로부터 접근하게 되면 ,
길이는 1 ~ N - 1 개 단위로 접어갈 수 있다.

1개마다 접는 경우,
혹은 쭉 가서 N - 1 개 단위로 접는 방법

일단 여기서 가장 중요한 것은 최대값을 얻어내기 위해서는 , 맨 아래에서 시작하는 경우
빈공간이 완전하게 존재하는 경우는 고려하지 않아도 된다.

그리고 , 음..
어떻게 해야할지 솔직히 감이 잘 오지 않는다.

일단 어떤 상황에서 몇개를 더 진행할 수 있따라는 사실을 담아놓는 것이 좋을 것 같은데..

일단 예시에서 주는 힌트 같은 것을 보면
오른쪽 부분은 더 길 수 있다라고 표현하고 있다.
즉 오른쪽으로 갈 때에 , 이전에 구간보다 길어서는 안된다라는 것을 알 수 있다.
이것은 초기 접는 정보의 값을 가지고서 구할 수 있을 것 같다.

예를 들어서 dfs(int init) 으로 넘기고, init == 2 라고 하면,
진행하다가 , 2를 넘어가면 안된다라는 것이다.

일단 그러면 감을 잡기 위해서 , 현재 넘어오는 짧은 길이의 문자열에서 답을 구할 수 있는지 진행을 한번 해보자.
이거는 거의 불가능하다 , 지금 나의 구현 실력으로서는 불가능하기 까지는 않지만 , 너무나도 비효율적이기에 , 안하는게 나을 것 같다.

생각을 계속 진행해보았다.

결국 답을 찾아봤음
답 보고도 설명이 없으니 전혀 이해를 못하겠다.

dp[n] 은 이것을 의미했었다.
String.charAt(n) 의 위로 올라올 수 있는 최대의 개수를 의미하는 거싱였다.
그래서 dp[0 ~ n - 1] 까지 채워져 있는 것이다....

즉 이 문제의 해답은 내가 생각했었던 어떠한 경우에 위에 올라올 수 있는 경우의 수가 아니라
그냥 해당 문자 위로 똑같은 문자가 몇개가 올라올 수 있냐 그것을 보는 문제였었다.

내가 생각했던 뭐 왼쪽으로는 더 길어도 된다 이런 거 신경쓰는 문제가 아니라 , 그냥
내 위에 끊기지 않고 올라올 수 있는 애들이 몇개가 되냐 그것을 i += 2 로 탐색해내는 것
이것이 이 문제의 핵심이였음..

많이 허탈하다. 아직 dp는 진짜 많이 먼 것 같다. 겨우 골드 3 문제도 엄청 어렵게 느껴졌었으니까
 */
public class Main {
    public static String s;
    public static int res , len;
    public static int[] dp = new int[1001];
    public static int dfs(int n){
        // 이미 방문한적이 있으면 반환
        if(dp[n] != -1) return dp[n];

        // 방문과 동시에 1로 초기화 , 최소값이 1이기 떄문에
        dp[n] = 1;

        // 넘겨받은 다음 문자열 부터 탐색 , 근데 왜 i += 2 를 할까?
        // 나에게 짝수 번 떨어져 있는 놈은 무슨 짓을 해도 , 내 위에 올라올 수가 없다. 그렇기 때문에 이렇게 하는 것이다.
        // 그래서 계속 진행하는 것임 지금까지 구했던 내 위로 올라올 수 있는 놈을 했던 경우가 크냐 , 아니면 지금 내 위로 올리는 놈을 올렸을 때가 크냐를 보는 것이다.
        // 중간이 비어있던 말던 그딴건 신경쓰지도 않았다.
        for(int i = n + 1; i < len; i+= 2){
            if(s.charAt(n) == s.charAt(i)) dp[n] = Math.max(dp[n] , dfs(i) + 1);
        }
        return dp[n];
    }
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

        // 입력받고
        s = input.readLine();

        // s.length 를 입력
        len = s.length();

        Arrays.fill(dp , -1);

        // 이건 확실히 , 내가 생각했던 방법과 비슷하다 , 초기 접는 위치를 정하는 것 아얘 접지 않는 경우도 존재
        for(int i = 0; i < len; i++){
            res = Math.max(res , dfs(i));
        }

        System.out.println(res);
    }
}