import java.util.*;
import java.io.*;

// 2482 : 색상환

/*
-- 전제 조건
서로 인접한 색깔들이 있다고 생각하자.
그 경우에 , 서로 인접하지 않게 k개를 고르는 경우의 수를 구하라 , 색깔의 개수는 n이다.

-- 틀 설계
일단 두 색을 인접한 색깔을 고르지 않는 것 그것이 중요하다.
모든 색깔들을 인접하지 않은 색깔을 뽑는 방법을 dfs 로 진행하게 되면 시간초과가 난다. 선택하고 , 안하고 두가지의 판단 기로에 서있는데
아무리 이미 선태했으면 다음 것을 선택하지 않는다고 하더라도 , 진행해봐야 할 경우의 수가 , 최대 N == 1000 이기 때문에 , 2 ^ 1000 과 가깝다.
이것이 아니더라도 , 엄청나게 큰 수에는 변함이 없다.

그렇다는 것은 무조건 dynamic programming 으로 풀어야한다.
일단 적은 색깔이 있는 경우를 생각해보자.

4가지의 색깔이 있고 , 2가지의 색깔을 골라야 하는 상황을 생각해보자.

일단 4가지의 색깔을 각 1 2 3 4 라고 칭했을 때,
1 2 3 4
o x o x
x o x o 이렇게 두가지의 방법이 존재한다.

음 그러면 한번 역순으로 구해볼까? , 만일 수가 있다면 , n / 2  의 개수가 고르는 최대의 수이다.
그리고 그 경우는 무조건 2가지이다. 즉 n 이 있을 때 n / 2 의 색깔을 고르는 경우는 무조건 2가지라는 것이다.

1 2 3 4 5 홀 수를 예로 한번 들어보자
o x o x x
o x x o x
x o x o x
x o x x o
x x o x o
5인 경우 3개는 될 수 없고 , 2개인 경우는 5가지의 경우가 가능하다 , 그리고 k == 1 인 경우는 당연하게도 n가지의 경우가 존재한다.

n이 홀 수인 경우 k == n / 2
혹은 , n이 짝수이고 (k == n / 2 무조건 2) k == n / 2 - 1 일 때의 개수를 구하는 것
이것이 중요할 것이다.

n == 8 인 경우를 4 , 3 으로 해보자.

1 2 3 4 5 6 7 8
o x o x o x o x
x o x o x o x o
일단 당연하게도 k == n / 2 일 때는 2가지이다.

k == 3 일 때
1 2 3 4 5 6 7 8
o x o x o x x x
o x o x x o x x
o x o x x x o x
o x x o x o x x
o x x o x x o x
o x x x o x o x
x o x o x o x x
x o x o x x o x
x o x o x x x o
x o x x o x o x
x o x x o x x o
x o x x x o x o
x x o x o x o x
x x o x o x x o
x x o x x o x o
x x x o x o x o
16 가지의 가짓수가 존재한다.

뭔가 솔직히 규칙성이 딱히 보이지는 않는다.
확실한 것은 맨 아래와 맨 위가 대칭을 이룬다는 것?

아니면 이전에 선택했던 것을 다시 선택하지 않는 것?

결국 답을 봤음

해답은 이렇다 dp[i][j] = k 라고 했을 때 , i 개의 색깔이 있고 j 개의 색깔을 골랐을 때 , 경우의 수이다.
즉 j == 0 일때에는 k 가 무조건 1이고 , j == 1 일 때에는 i의 경우의 수가 있는 것을 이용하면 된다.

일단, 순차적으로 i == 2 인 경우는 구하지 않아도 된다.
왜냐하면 이미 dp[i][1] = i 로 1은 다 채웠고,
그리고 i 보다 j가 클 수 없다.
정확히 말하면 i / 2 보다 j가 크면 안된다.
그러면 경우의 수가 0이 되기 떄문이다.

그리고 일단 모든 dp[i] 의 [1] 값들은 다 채운 상태이다.
그렇기 때문에 j는 2부터 시작하면 된다.

일단 , 두가지의 경우로 나눌 수 있다 , 위에서 말했듯
n == 10 이라고 가정해보자 , 그리고 10을 선택하냐 , 안하냐를 결정해보자.

일단 이 숫자들은 실제로 숫자를 의미하지 않는다 , 단지 숫자에 의미가 있는 것이 아닌 , 이것들이 인접했냐 안했냐에 중점을 두어야 한다.

일단 하나하나의 숫자들을 선택해가면서 , 두가지의 경우로 나뉠 수가 있는 것이다.
i 번째 숫자를 선택하냐 하지 않냐 , 만일 선택하게 된다면 , 이전 i - 1 번쨰 숫자를 선택하지 못한다.
그렇다는 것은 i - 2 번째 숫자를 선택하였을 때 , 그 경우의 숫자를 구하면 된다. 그렇다는 것은 dp[i - 2][j - 1] 을 더하면 되는 것이다.

그 다음에 , 선택하지 않은 경우 , 그 경우에는 선택하지 않았으니까 , dp[i - 1][j] 의 경우를 더해야 한다.
왜냐하면 , 일단 지금 선택하지 않았으니까 i - 1 번째의 색깔을 선택할 수 있는 것이고 , 그리고 선택하지 않았으니 , j개를 선택한 것을 가져와야 한다.

그 다음에 마지막에 답을 구하는 경우에는 맨 마지막 숫자를 고르게 되면 첫번째 숫자를 고르지 못하게 된다.
그렇다는 것은 i - 3 개의 숫자들 중에 고르는 것이고 , 현재 n - 1 를 가져와야 한다 , 왜냐하면 마지막에 선택을 했으니까

그리고 선택을 하지 않는 경우에는 , i - 1 개 중에서 색깔을 n 개 고른 것을 가져오면 된다.

내가 봤을 때 , 굳이 맨 마지막 , 즉 N을 선택했을 때 즉 dp[N][j] 를 굳이 고려하지는 않은 것 같다.
왜냐하면 무조건 마지막에 계산 할 때에는 dp[N - 3][K - 1] + dp[N - 1][K] 이기 때문이다.

내가 이해가지 않았던 부분은 딱 하나이다 , 마지막의 경우 , 즉 dp[i][j] = i 개의 색이 있을 때 , j 개의 색깔을 뽑는 경우의 수를 구하는 것이였다.
그렇기 때문에 , i == N 일 때 , j 가 2 이상이라면 ? 당연하게도 , 마지막을 뽑았을 경우에 , dp[N - 2] 이 아닌
dp[N - 3] 을 고려해야 하기 때문이다.
즉 , 내 가정이 맞다면 for(int i = 0; i < N; i++) 도 맞아야한다.

역시나 맞았다 , 마지막 즉 for 문에서 굳이 i <= N 을 해줄 필요는 당연하게도 없었다

또 이해가 안가는 부분이 있다 왜 ? j <= (i + 1) / 2 일까?
만일 i 가 3이라고 하였을 때 , 색깔은 하나밖에 선택하지 못한다.
왜냐하면 , 3개일 때 2개를 선택을 하지 못하기 때문이다.

근데 이 문제의 가정을 보면 그렇지 않다.
dp[3][2] == 1 이라는 답이 나오게 된다.

이게 도대체 말이 안된다...
문제에서 주어진대로 한번해보자.

문제에서 주어진 것으로 따르면 절대로 색깔이 20개가 존재할 때 ,
11개의 색깔을 선택하는 것은 의미가 전혀 없다.

한번 실험을 해보자.

dp[3][2] = 1 이것만 봐도 말이안된다.
그리고
dp[21][11] = 1 이것도 말이 안된다.
어떻게 3개중에 2개를 선택하는 경우가 1개이지?

1 2 3
o x o 안된다.
x o o 안된다.
o o x 안된다.

아무리 봐도 색깔 3개의 색이 존재할 때 , 도대체

1 2 3 4
o x o x
x o x o

1 2 3 4 이것을 체크해보고 , 깨달았다...
이 문제의 경우 i == N 일 때의 경우를 배제하고 있다,
아얘 반복문에서 dp 를 구할 때 , i == N 인 경우는 아얘 배제를 하고 있다는 것이다.
왜냐? 짜피 dp[N][K] 를 구할 때에는 dp[N - 1] 부터만 필요하기 때문이다.
즉 dp[N]... 값들이 정확할 필요가 전혀없다는 것이다.

for(int i = 0; i <= N; i++) 이렇게 진행하였을 때 ,
dp[4][2] = 3 으로 나오는 것 부터 알 수가 있다 즉 i == N 일 때 루프는 정말 의미없는 연산인 것이다.

그렇기 때문에 N 은 그냥 구하지 않는다고 가정하고 보면 , 즉 의미없는 루프라고 가정하고 보면 답이나온다.
dp[3][2] 이건 당연히 가능한 것이였다.
내가 생각한 경우는 색이 3개만 있을 때 였다.
그렇게 보면 당연히 2개를 선택할 수가 없다고 생각할 수밖에 없다.

1 2 3
o x o
x o o
o o x

이런 경우말이다. 하지만 , 여기서 색을 3개에서 고르는 경우이지 , 실제로 색이 3개가 아니다 즉 , 4가지의 색이라고 가정했을 때 ,
뒤에 4가 숨어있단 말이다 즉
1 2 3 의 경우에 하나의 경우는
o x o 라고 할 수 있다.

이래도 규칙 위반이 아니다 , 왜냐하면 뒤에 4가 있기 때문이다.

이런식으로 했기 때문에, 계속 dp 값을 구할 때 , i 번째의 색깔을 선택했을 때 , n - 1번 째를 선택하지 않은 경우만 고려했던 것이였다.
즉 이 문제는 마지막 dp[N] 을 구할 때만 신경써주고 , 나머지의 경우에서는 그냥 1번째 색깔 , 즉 다시 이어지는 구간을 생각하지 않아도 됐었던 것이다.

그렇기 때문에 , 홀 수개 일 때에는 서로 색깔을 선택할 때 , 한칸만 떨어져있으면 되기 때문에 , 그 경우를 고려해서 j <= (i + 1) / 2 로 했던 것이였다.

그리고 마지막의 경우에서만 1번째 색깔이랑 인접해있는 경우를 고려해서 , 마지막 것을 선택하였을 때에는 본인 , n - 1 번째 , 1번째를 고려해서 현재 N 개의 색상에서
이렇게 3개를 뺀 N - 3 개 중에서 K - 1 개의 색깔을 고른 경우를 고려한 것이다 , 그리고 선택하지 않았을 때에는 당연하게도 N - 1 개 중에서 K 개를 고른 경우의 수를 더해주면 답을 구할 수 있게 되는 것이다.

즉 이 문제는 맨 마지막 , 즉 dp[N][j] 의 경우의 수들을 구하기 전까지는 원통이 아닌 직선으로 생각해주고 , 왼쪽 , 오른쪽이 아닌 왼쪽만을 고려해서 문제를 보다 쉽게 만든 것이다.
솔직히 이걸 어떻게 생각하는지 모르겠다 , 도대체 dp 문제는

내가 봤을 때 post 작성한 사람들은 이거를 다 정확하게 이해하고 있지는 않은 거 같다.

결과적으로는 , dp[i][j] 이것을 i 개의 색이 있을 때 j개의 색을 선택하는 경우를 정확하게 유지하면서 , 다음 것들을 차근차근 구해가는 과정이다.
 */
public class Main {
    public static final int MOD = 1000000003;
    public static int N , K;
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(input.readLine());
        K = Integer.parseInt(input.readLine());

        int[][] dp = new int[N + 1][N + 1];

        for(int i = 0; i <= N; i++){
            dp[i][1] = i;
            dp[i][0] = 1;
        }

        for(int i = 3; i < N; i++){
            for(int j = 2; j <= (i + 1) / 2; j++){
                dp[i][j] = (dp[i - 2][j - 1] + dp[i - 1][j]) % MOD;
//                System.out.println("i : " + i + " j : " + j);
                System.out.println("dp[" + i + "][" + j + "] = " + dp[i][j]);
            }
        }

        System.out.println((dp[N - 3][K - 1] + dp[N - 1][K]) % MOD);
    }
}