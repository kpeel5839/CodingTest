import java.io.*;
import java.util.*;
import java.util.function.Function;

// 17182 : 우주 탐사선

/**
 * -- 전제 조건
 * 최소 비용으로 모든 행성을 다 돌때
 * 비용을 출력하라.
 * -- 틀 설계
 * 이 문제는 무엇인가 비트마스킹 문제인 것 같다라는 느낌이 팍든다.
 *
 * 일단, 첫번째 지점은 무조건 고정이다.
 * 그렇기 때문에 첫번째 지점은 무조건 1로 만들고 진행한다.
 *
 * 그러고서 다 도달하였을 때, return 0 를 던져준다.
 * 그리고 현재 본인이 가지고 있는 dp 값과 거기로 이동할 떄 들었던 비용을 더하는 것임
 *
 * 만약 이게 맞다면 완전 그냥 외판원 순회랑 비슷한 문제라고 생각이든다.
 *
 * -- 해맸던 점
 * 일단 처음에는 당연하게 비트마스킹을 떠올렸다.
 * 비트 마스킹으로 최소 비용을 계속해서 갱신시켰다.
 *
 * 근데, 이게 문제점이 하나 생겼다.
 * 이미 방문했던 지점을 방문해도 된다라는 것
 * 심지어 그것이 최단 거리인 경우도 분명히 존재했음
 *
 * 그리고 내가 생각했던 이런 상황도 무조건 중복 방문을 진행했었어야 했음
 * ex )
 * 4 1
 * 0 1 0 0
 * 1 0 1 1
 * 0 1 0 0
 * 0 1 0 0
 *
 * 분명하게 이런 상황에서는 계속해서 1번 정점을 중복 방문해야함
 * 왜냐? 그래야지 갈 수 있으니까
 * 그래서 결국 카테고리를 봤음
 *
 * 근데 플로이드 와샬이 있네?
 * 그래서 생각해봤더니
 * 중복방문을 할 필요가 없는 것임 (중복 방문에 집착하는 이유는 비트마스킹으로 해결하려 할 때, 그것이 아닌 그래프 탐색에서 중복방문을 허용하는 순간 stack over flow 가 나버린다.)
 *
 * 왜냐하면 그냥 플로이드 와샬의 개념 자체가 K 를 변경해가면서
 * K 를 거쳐간다면? 어디 정점으로 최소 비용으로 가는 경우를 갱신해준다.
 *
 * 그렇다라는 것은 뚫려 있지 않던 경로도 플로이드 와샬이 뚫어준다라는 것임
 *
 * 위와 같은 예씨에서도 아마 플로이드 와샬을 돌리고 나면 (본인 정점은 무조건 0 으로 유지한다고 했을 때)
 *
 * 0 1 2 2
 * 1 0 1 1
 * 2 1 0 2
 * 2 1 2 0
 *
 * 이런식으로 바뀔 수 있다
 * 그러면 당연하게 중복 방문을 고려하지 않아도
 * 0, 2, 3 정점도 1번 정점이 아닌 다른 정점으로 갈 수 있는 최소 비용 경로가 생긴 것이다.
 * 즉, 그냥 인접한 간선이 생겼다라고 생각해도 무방한 것이다.
 *
 * 그렇기 때문에 위와 같은 경우에 플로이드 와샬로 길을 뚫어 놓고 간다면? 굳이 중복방문을 고려하지 않아도
 * 가능한 것이다 위와 같은 경우에서 어디로 가던지 최소비용이지만
 * 예시를 들면 1 -> 0 -> 2 -> 3 이렇게 해도 된다.
 *
 * 그래서 결국 5라는 답을 구할 수 있을 것이다.
 *
 * 이런 식으로 플로이드 와샬로 원래 존재하지 않던 경로, 즉 인접하지 않던 정점들도 그냥 최소비용으로 간선들을 갱신하며 마치 인접한 것처럼
 * 처리하는 기법이 들어가는 것 같다.
 *
 * 이게 왜 골3 인지는 이해가 가지 않는다. 오히려 외판원 순회보다 더 어려운 것 같은데?
 *
 * 아 아니다.
 * 위의 예시를 잘 못 생각했다.
 * 여기서는 연결되지 않았다고 생각하는 정점들이 없는 것 같은 본인 -> 본인이 아니면
 *
 * 그래서 내가 생각한 예시따위는 존재하지 않는다.
 * 내가 생각한대로 되려면
 * 오히려
 * 0 1 100 100
 * 1 0 1 1
 * 100 1 0 100
 * 100 1 100 0
 * 이렇게 되어야 할 것 같다.
 * 차라리 이어지지 않았다고 생각할 수 있는 것을 큰 값을 주는 것이다.
 *
 * 이 문제에서는 사실 연결되어 있는 정점들이 오히려 그 비용을 최소 비용으로 갱신시키면서
 * 어떠한 정점으로 움직일 때, 무조건 그 정점으로 가는 길이 최소비용으로 유지될 수 있도록 플로이드 와샬을 사용하는 것이다.
 *
 * 그러니까, 이전에 말했던 것처럼 없던 정점을 잇는 형식인 것이 아니라
 * 어떤 정점으로 갈 때 그 값이 너무 높아서, 중복 방문을 해야 하는 경우에 그것이 아닌 플로이드 와샬 알고리즘을 실행하여
 * 어떤 정점에서 정점으로 가는 cost 를 무조건 최소비용으로 유지해 중복방문을 실제로는 하더라도 그것을 고려하지 않도록 해주는 것이다.
 *
 * 정리하자면
 * 어떤 정점으로 갈 때 현재는 최소 비용이 아니라 다른 정점을 방문하여서 최단 경로로 가야해 중복방문이 불가피 한 문제를
 * 플로이드 와샬을 통해서 cost 를 최소비용으로 유지함으로써 중복 방문을 고려하지 않아도 되는 문제로 만드는 것이 이 문제의 핵심이다.
 */
public class Main {
    static int N;
    static int S;
    static int INF = 1_000_000_000;
    static int[][] graph;
    static int[][] dp;

    static int dfs(int bit, int now) {
        // 현재 어떤 지점들을 방문하였는지와, 현재 어떤 지점인지를 넘긴다.
        if (bit == (1 << N) - 1) { // 모든 지점을 다 방문한 경우
            return 0;
        }

        if (dp[bit][now] != INF) { // 이미 방문해서 여기서부터 최단 경로는 결저오딘 상태일 때이다. (bit 를 보고 지점이 얼마나 남았는지와, 현재 정점으로 부터 출발하면 최단 경로로 다 돌 수 있는 경우의 비용이 들어있다.)
            return dp[bit][now];
        }

        for (int i = 0; i < N; i++) {
            if (i != now && (bit & (1 << i)) == 0) { // 현재 정점이 아니고, 이미 방문한 지점도 방문해도 괜찮음
                dp[bit][now] = Math.min(dp[bit][now], dfs(bit | (1 << i), i) + graph[now][i]);
            }
        }

        return dp[bit][now]; // 최종적으로 결정된 최단 비용을 뱉어낸다.
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        Function<String, Integer> fun = Integer::parseInt;

        String[] input = br.readLine().split(" ");
        N = fun.apply(input[0]);
        S = fun.apply(input[1]);
        graph = new int[N][N];
        dp = new int[1 << N][N];

        for (int i = 0; i < 1 << N; i++) {
            Arrays.fill(dp[i], INF);
        }

        for (int i = 0; i < N; i++) {
            input = br.readLine().split(" ");
            for (int j = 0; j < N; j++) {
                graph[i][j] = fun.apply(input[j]);
            }
        }


        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                for (int k = 0; k < N; k++) {
                    if (i != j) {
                        graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);
                    }
                }
            }
        }

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(graph[i][j] + " ");
            }
            System.out.println();
        }

        System.out.println(dfs(1 << S, S));
    }
}
