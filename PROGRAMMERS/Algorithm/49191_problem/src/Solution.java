import java.util.*;
import java.io.*;

// 결국 답을 보았음..
// 계속 생각을 했는데, 순간 귀찮음의 충동을 이기지 못해서 답을 보았는데
// 생각보다 굉장히 단순했음

/*
일단 플로이드 워샬 알고리즘을 통해서,
모든 정점에서 어떤 정점까지 갈 수 있는지에 대해서,
즉 내가 어떤 정점에게는 지고, 어떤 정점에게는 이길 수 있는지 체크하는 게 중점인 문제였음

그래서, 처음에 그래프를 받아서 인접행렬에 등록을 하면 된다.
(a, b) 의 쌍이 들어왔을 떄
arr[a][b] 는 1이다.
왜냐? a -> b, a 는 b 를 이겼다는 표시로 1이라고 설정할 수 있다.

그리고 arr[b][a] = -1 이다. b -> a 는 a 에게 졌다라는 의미로 -1을 집어넣을 수 있다.
그래서, 플로이드 워샬 알고리즘을 통해서, 어떤 노드에게는 지고, 어떤 노드에게는 이기는 지
그게 갱신이 되려면?
당연하게도, arr[i][k] == 1 && arr[k][i] == 1 이거나
이말은 즉 이 문제와 같이 1 -> 2 -> 5에서
1 은 결국 5번을 이긴것과 다름이 없다
그러면 이런식으로 초기화가 가능한 것이다 arr[1번][2] == 이기고 && arr[2번][5번] == 이겼으면
그러면 arr[1][5] = 이겼고 arr[5번][1번] == 졌다
이런느낌으로 가면 되고
반대도 똑같이 해주면 된다.
근데 arr[1][1] 이런 것 같은 경우는 어떻게 관리해야 할까?
사실, 이런 경우는 arr[1][1] -> arr[1][4] 이 말은 즉, 둘다 1일 수도 없거니와
arr[i][i] 는 0으로 초기화 되어 있기 때문에, arr[1][4] 와 같다 그래서 신경쓸 바가 아니다.
*/
class Solution {
    public int solution(int n, int[][] results) {
        int answer = 0;
        int[][] dp = new int[n + 1][n + 1];

        for (int i = 0; i < results.length; i++){
            int a = results[i][0];
            int b = results[i][1];

            dp[a][b] = 1;
            dp[b][a] = -1;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                for (int k = 1; k <= n; k++) {
                    if (dp[i][k] == 1 && dp[k][j] == 1) { // i -> k -> j 의 경우
                        dp[i][j] = 1;
                        dp[j][i] = -1;
                    }

                    if (dp[i][k] == -1 && dp[k][j] == -1) { // i <- k <- j 의 경우
                        dp[i][j] = -1;
                        dp[j][i] = 1;
                    }
                }
            }
        }

        for (int i = 1; i <= n; i++) {
            int count = 0;
            for (int j = 1; j <= n; j++) {
                if (dp[i][j] != 0) {
                    count++;
                }
            }
            if (count == (n - 1)) {
                answer++;
            }
        }

        return answer;
    }
}