class Solution {
    int MOD = 20170805;

    /**
     이 문제는 절대로 dfs 로 풀어낼 수 없는 문제이다.
     일단, 1 <= m, n <= 500 이라는 범위가 말도 안되기 때문이다.

     그렇기 때문에 DP 의 형식으로 접근해야 한다.
     모두 0 인 경우 그냥 이전 DP 형식으로 해도 되지만, 지금은 그렇게 할 수 없다.

     그렇기 때문에 내가 고안한 방법은 2가지 방향에서 입력을 받는 것이다.
     를 dp[m][n] 크기로 만들고 여기서 2 를 추가해주어서
     최종적인 array 형태를 dp[m][n][2] 의 형태로 만드는 것이다.

     그리고, dp[m][n][0] 은 위, dp[m][n][1] 은 왼쪽을 기준으로 한다.
     그러면 이것부터는 계산이 쉽다.

     그럼 이제 계산을 어떻게 해야 할까?
     만일 0인 경우라면 [0] 과 [1] 이 둘다 같은 값이여야 한다.
     왜냐? 얘내들은 본인 지점으로 들어오기만 하면 어디든지 갈 수 있으니까
     여기서 관건은 바로 주변에 2번이 있을 때이다.

     1번은 상관이 없다. 그냥 무시하면 되니까
     하지만 2번이 들어있다라면 까다로워지지만 이 방법을 사용하게 되면 쉽게 문제가 풀릴 수가 있다.

     2번이 만일 위의 방향에 존재한다?
     그러면 [0] 번 값을 이용해서 더해주고
     왼쪽에 존재한다? 그러면 [1] 번 값을 이용해서 더해주면 된다.

     그리고 최종적으로는 dp[m][n][0] 을 출력해주면 될 것 같다. (어짜피 0 인 경우는 그 값이 [0] [1] 이 같음)

     그리고 배열 사이즈는 왼쪽과, 윗쪽을 0으로 채워놔야 하기 떄문에
     dp[m + 1][n + 1][2] 로 형성한다.

     그래서 일반적인 점화식은
     dp[i][j][0] = dp[i - 1][j][0] + dp[i][j - 1][1] 이다.

     확실히 설계의 중요성을 느낀 문제였다.
     오른쪽 혹은 왼쪽으로 가야한다라는 조건이 명확히 명시되지 않아
     개빡치긴하지만 그래도 재밌는 문제였다 사실 이 문제는 잘 풀려서 기분이 좋았다 ^^

     근데 오른쪽 혹은 아래로만 가야한다라는 조건이 명시되어 있었나보네
     난 못 봤는데

     */

    public int solution(int m, int n, int[][] cityMap) {
        // MOD 값으로 나눠서 넣어야 한다라는 것을 잊지말자
        int[][][] dp = new int[m + 1][n + 1][2];
        dp[1][1][0] = 1;
        dp[1][1][1] = 1; // 초기 값 세팅

        for (int i = 1; i <= m; i++) { // 0 은 위, 1 은 왼쪽
            for (int j = 1; j <= n; j++) {
                if (!(i == 1 && j == 1)) {
                    if (cityMap[i - 1][j - 1] == 0) { // 0 인 경우 그냥 양쪽 다 더해준다.
                        dp[i][j][0] = (dp[i - 1][j][0] + dp[i][j - 1][1]) % MOD; // 이러한 점화식이 나오게 된다.                    
                        dp[i][j][1] = dp[i][j][0]; // 둘이 똑같은 값으로 유지되어야 하니까?
                    } else if (cityMap[i - 1][j - 1] == 2) { // 2 인 경우                
                        dp[i][j][0] = dp[i - 1][j][0];
                        dp[i][j][1] = dp[i][j - 1][1];
                    }
                }
            }
        }

        // for (int i = 0; i <= m; i++) {
        //     for (int j = 0; j <= m; j++) {
        //         System.out.print(dp[i][j][0] + " ");
        //     }
        //     System.out.println();
        // }

        return dp[m][n][0] % MOD;
    }
}