import java.util.*;
import java.io.*;

/**
 * 결국 이렇게 푸는 것이 맞았었음
 * 하지만 이 문제 같은 경우 이렇게 풀 경우에는
 *
 * 01000
 * 01010
 * 01010
 * 00010
 *
 * 이런 경우가 있다.
 * 이렇게 되면, 이 문제는 풀리지 않는다.
 *
 * 이 문제의 이렇게 풀 수 있는 핵심적인 부분은 왼쪽 혹은 위로 가면 최단 경로가 안될 수 밖에 없는 것이다.
 * 나도 처음에 이런 생각을 했었다.
 * 하지만, 이 경우는 장애물이 없는 경우에만 해당하게 된다
 *
 * 장애물이 위와 같은 예시로 있을 경우?
 * 이렇게 문제를 해결할 수 없다.
 *
 * 하지만 내가 이전에 풀었던 방법으로 하게 되면 문제를 풀어낼 수가 있다. (시간초과가 나긴 하지만)
 *
 * 그래서, 이 문제는 무엇인가 굉장히 찝찝한 문제이다.
 *
 * 그래서 결론은 이 문제는 오른쪽, 아랫쪽만 선택적으로 선택하는 문제이다.
 * 위와 왼쪽은 선택하지 않는다.
 * 장애물이 없다라는 가정하에 학교가 가장 왼쪽 상단, 집이 가장 오른쪽 하단이기 때문이다.
 *
 * 그래서 그런식으로 하면 너무나도 문제가 쉬워진다.
 * [1][1] 은 갈 수 있는 경우가 하나이다.
 * 그리고, [1][2], [1][3] 과 같은 경우도 갈 수 있는 방법은 다 한 가지이다.
 *
 * 하지만 [2][2] 는 2가지이다.
 * 여기서 볼 수 있는 점은 현재 지점으로 왼쪽, 윗쪽을 보게되면, 거기까지의 가짓수를 알 수 있다.
 * 당연하게도 현재 지점으로 오려면 그러면 왼쪽이나, 윗쪽으로 이동을 하지 못하니 무조건 왼쪽, 윗쪽에서 오는 경우밖에 없는 것이다.
 * 그래서 그냥 dp[i - 1][j] + d[i][j - 1] 즉 dynamic programming 의 가장 기본적인 예시, 길 찾기와 같은 문제로 변환시킬 수 있는 것이다.
 *
 * 그래서 이 문제는 이렇게 풀 수 있었고, 살짝 이상한 문제인 것 같다.
 * 일단, dfs 로 가장 현명한 선택을 했다고 생각했고, 로직에도 효율을 망칠 로직은 없어보였지만, 아무래도 가로 세로 길이가 최대 100인 점을 미루어 보았을 때,
 * dfs 로는, 즉 진짜 그래프 탐색을 해보면서 풀 수 있는 문제는 아닌 것 같다라는 생각이 든다.
 */
class Solution2 {
    static final int MOD = 1_000_000_007;

    public int solution(int m, int n, int[][] puddles) {
        boolean[][] impossible = new boolean[n + 1][m + 1];
        int[][] dp = new int[n + 1][m + 1];

        for (int i = 0; i < puddles.length; i++) {
            impossible[puddles[i][1]][puddles[i][0]] = true;
        }

        dp[1][1] = 1;
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[i].length; j++) {
                if (!impossible[i][j]) {
                    if (i == 1 && j == 1) {
                        continue;
                    }

                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;
                }
            }
        }

        return dp[n][m] % MOD;
    }
}