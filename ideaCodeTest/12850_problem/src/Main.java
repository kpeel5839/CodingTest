import java.util.*;
import java.io.*;

// 12850 : 본대 산책2

/*
-- 전제조건
그냥 본대랑 정보과학관이랑 나뉘어져 있는데,
정보과학관에서 본대에서 산책을 갔다고 오는 것임,
근데 본대에서 산책을 진행하는데 , 한번도 멈추지 않고 , 결국 돌아오는 방법의 수를 구하는 것이다.

-- 틀설계
인접행렬의 곱셉을 진행하면 된다라는 것이 있었음.
인접행렬은 어디 정점에서 어디 정점으로 갈 수 있다라는 것을 표현한다.
근데 , 인접행렬 그 자체에서는 , 처음에 갈 수 있는 경우 1 , 가지 못하는 경우 0 , 즉 직접적으로 연결되어 있지 않으면 저런식으로 표현하게 된다.
근데 이게 마법같이 , 같은 인접행렬 , 초기 인접행렬을 더하게 되면 ? 마법같이 2번 움직였을 때 , 다시 원래 지점으로 돌아올 수 있는 경우가 갱신이 된다.
그렇기 때문에 이 점을 이용해서 , 인접행렬을 주어진 수 만큼 제곱을 하면 되는 것이다.
근데 , 제곱해야 하는 수가 10억이다.(최대)
그렇기 때문에 제곱도 분할정복으로 진행해야 한다.
일단 , 내가 한번 효율적으로 2의 제곱을 분할정복으로 빠르게 구하는 방법을 고안해낸적이 있었는데
그 방법을 그대로 행렬 곱에 적용해야 할 듯하다.
일단 내가 생각했던 방법은 이러했다.
해당 수가 짝수이면 , 즉 2로 나눠지면 제곱을 나눠주는 것이다.
예를 들어서 2 ^ 6 이라고 가정하였을 때에는
2 ^ 6 -> (2 ^ 2) ^ 3
이렇게 줄일 수 있다.
그럼 이것을 계속 점차적으로 줄여본다고 가정하자
2의 제곱을 분할정복으로 차츰 구해간다고 가정해보자.
그 경우 2 ^ 20 을 분할해보면
진행을 이런식으로 할 수 있을 것이다.
2 ^ 2 ^ 10

2 ^ 2 ^ 2 ^ 5
2 ^ 2 ^ 2 이 경우 해결 방법이 필요한데
이 경우를 해결하기 위해서 조금 더 작은 단위로 해보자.
2 ^ 7 로 한다고 가정해보자.
2 ^ 7 은 128이다.
일단 처음에 2로 나누어 지지 않는다.
그래서 2를 한번 곱해줄 수 있다.
2 * 2 ^ 6
이런식으로 표현이 가능하다.

이 수와 곱해져야 한다.
본인이 지금 2 ^ (7 - 1) 이 수와 2가 곱해져야 한다.

그래서 계속 진행을 하면
2 * ((2 * (2 ^ 2)) ^ 2) = 128

한번 재귀적으로 풀어보자.

그럼 이런식으로 한번 행렬 곱을 한번해보자.
일단

011
101
110

이러한 행렬을 한번 곱을 진행해보자.

-- 해맸던 점
그래 내가 생각한 방법이 맞는데 틀릴리가 없었었음
다른 사람들과의 코드는 달랐지만 내가 이해한건 정확했으니까
해맸던 점은 일단 , 내가 3 3 행렬 곱을 하다가 그 사이즈 변경안해주었었고,
그리고 call by reference 여가지고 그냥 될 줄 알았는데,
반환을 받았어야지 되었었다.
그래서 matrix2 = pow(matrix1 , matrix2 , m); 으로 진행하고
그 다음 결과를 출력하였는데 맞았음

-- 결과
일단 어떠한 그래프를 행렬로 표현하였을 때 , 그 행렬을 제곱하면
각 자릿수는 자리가 의미하는 1 -> 2 , 1에서 시작해서 2로 가는 경우중
제곱한 수만큼 움직인다고 했을 때의 경우의 수를 나타낸다.
즉 matrix[1][2] 이고 , 제곱을 3번했다고 하면
matrix[1][2] 안에 들어있는 수는 1 번에서 시작해서 2번으로 3번 움직여서 도착하는 경우의 수를 나타낸다.

이거를 알면 그 다음 부터는 굉장히 쉽다.
일단 해당 행렬은 무조건적으로 8 * 8 이다.
그렇기 때문에 , 행렬의 사이즈가 변할일도 없다.
그렇기에 , 더 쉽고(바뀐다고 하더라도 그냥 계산하면 되긴 한다.)

그래서 행렬곱을 진행한다.
행렬곱은 왼쪽 행렬은 가로로 진행 , 오른쪽 행렬은 행으로 진행하는데
왼쪽행렬은 행 번호만 달라지고 무조건 0번째 열부터
오른쪽 행렬은 열 번호만 달라지고 무조건 0번째 행부터 시작한다.
이런식의 특성을 이용하여서 , 3중 루프문을 구성하여 행렬의 곱을 구할 수 있고 , MOD 연산을 이용하여서,
나머지 값을 구해주면 된다.

그리고 분할정복으로 인한 제곱 수 빨리 구하기는
그냥 2 ^ 7을 예로 들면
계속 지수를 작게 만들어주는데 ,
계속 바깥 지수를 2로 빼준다고 생각하면 된다.
어떤 식으로 냐면 이런식으로 이다.

일단 2로 나눠지지 않는 경우는 트릭을 이용하여서 지수를 낮춰줄 수 있다,
1만 낮춰주더라도 2로 나눌 수 있는 수가 되기 때문에(짝수)
본인과 같은 수를 한번만 더 곱해준다.
첫번째는 이렇게 진행할 수 있다.

2 * (2 ^ 6) 이런식으로 말이다.

이제 2 ^ 6 에 대해서 제곱수를 낮춰주어야 한다.

그러면
2 * ( (2 ^ 3) ^ 2)
이런식으로 낮춰줄 수가 있다.

그리고 또 안에서 연산을 진행할 수가 있다.
2 ^ 3 이기에
2 를 또 곱해준다.

2 * (( 2 * (2 ^ 2)) ^ 2)

이런식으로 구성해줄 수 있다.

이제 2 ^ 2 를 나누어주고 그러면 지수가 1이 되기 때문에 여기서는 그냥 진행해준다.
그래서 계산을 진행해준다.

2 * ( ( 2 * ( 4 ) ) ^ 2)
이런식으로 식이 구성이 되고

2 ^ 3 을 이어나가면
2 * ( ( 8 ) ^ 2 )
이렇게 된다.
그러면 또

2 ^ 6 이였던 것을 이어나가면
2 * ( 64 )
그리고 또 이어나가면 128이다.

이런식으로 계속 분할을 진행할 때에는 밑의 수를 유지하면서 , 계속 바깥으로 지수 2를 빼내면서 지수가 1이 되는 순간에 역으로부터 순서대로 구하면서
구하는 방법 , 이게 분할정복을 이용한 거듭제곱 방식이다.
 */
public class Main {
    public static final long MOD = 1_000_000_007;
    public static long[][] pow(long[][] m1 , long[][] m2 , int m){

        // m == 1 이니까 m1 반환해준다.
        if(m == 1) return m1;

        if(m % 2 == 0){ // 나눠질 떄

            // 계산된 값 반환 받아서 , 제곱을 진행해준다 , 계속 해서 지수 2를 바깥으로 빼주었기 때문에
            long[][] m3 = pow(m1 , m2 , m / 2);
            m2 = mul(m3 , m3);

            return m2;
        }

        else{ // 나누어지지 않을 때

            // 나눠지지 않기에 , 원래의 값을 빼줘서 지수를 1만 낮춘다음 , 계산된 값을 반환받아서 계산 뒤에 반환을 진행한다.
            m2 = mul(m1 , pow(m1 , m2 , m - 1));
            return m2;
        }
    }
    public static long[][] mul(long[][] m1 , long[][] m2){
        long[][] res = new long[8][8];
        for(int i = 0; i < 8; i++){
            for(int j = 0; j < 8; j++){
                for(int k = 0; k < 8; k++){
                    res[i][j] = (res[i][j] + m1[i][k] * m2[k][j]) % MOD;
                }
            }
        }
        return res;
    }
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

        int m = Integer.parseInt(input.readLine());

        long[][] matrix1 = {
                {0, 1, 1, 0, 0, 0, 0, 0},
                {1, 0, 1, 1, 0, 0, 0, 0},
                {1, 1, 0, 1, 1, 0, 0, 0},
                {0, 1, 1, 0, 1, 1, 0, 0},
                {0, 0, 1, 1, 0, 1, 0, 1},
                {0, 0, 0, 1, 1, 0, 1, 0},
                {0, 0, 0, 0, 0, 1, 0, 1},
                {0, 0, 0, 0, 1, 0, 1, 0}
        };

        long[][] matrix2 = matrix1.clone();

        matrix2 = pow(matrix1 , matrix2 , m);

        System.out.println(matrix2[0][0] % MOD);
    }
}
