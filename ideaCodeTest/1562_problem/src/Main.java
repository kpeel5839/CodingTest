import java.util.*;
import java.io.*;

// 1562 : 계단 수

/*
-- 전제 조건
n 이 주어질 때 길이가 n 이면서 계단 수인 것들을 전부다 구한다.
정답은 1,000,000,000 (10억) 으로 나눈 값을 출력한다.
-- 틀 설계
어떻게 설계를 할 수가 있을까?
일단 확실한 것은 계단수란 인접한 모든 숫자가 차이가 1이 나는 상황이다.
그리고 길이가 N이면서 , 0 부터 9까지 모든 숫자가 등장하는 게단수를 구해야하는 것이다.

그렇다라는 것은 일단 길이가 N <= 9 이다? 그러면 무조건 0이다. 일단 0 ~ 9 까지 숫자가 모두 등장해야 하는데,
그럴 수가 없기 때문이다.

일단 그러면 dp[10] 부터 생각해본다고 해보자.
9876543210 왜냐하면 , 0으로 시작하는 수는 정수가 아닐 뿐더러 여기서도 명시하고 있듯 0으로 시작하는 수는 계단수가 아니라고 명확하게 정의 내렸기 때문이다.

한 자리에는 10개의 숫자가 들어올 수 있다.(10진법)
해당 숫자를 탐색하는 것도 아니다 , 왜냐하면 주어진 수가 없기 때문이다 , 이 수 안에 계단 수가 몇개가 들어있냐가 아닌,
총 그냥 숫자중에 N자리 숫자에서 , 계단수가 몇개인가를 묻는 것이기 때문이다.

일단 항상 그렇듯 이 수가 계단 수인지 , 해당 dp[i] 가 계단 수가 몇개인지를 보았을 때 ,
다음으로 될 수 있는 계단 수는 몇개가 있을 지를 구할 수 있을 까 ? 그러니 dp[i] 를 알 때 , dp[i + 1] 을 알 수 있을까?

그리고 힌트로 N 이 1일 때 부터 N 이 40일 떄까지 모두 더한 값을 알려준 것도
해당 자리수를 설정하고 거기서 탐색하는 형식의 풀이 방법이 아닌 , bottom - up 방식으로 접근하는 풀이일 것 같다.

일단 그러면 우리는 dp[10] == 1 이라는 사실을 안다.
그렇다라는 것은 한자리만 추가가 되었을 때를 경우를 한번 구해보자.

일단 , 추가될 수 있는 자리?

dp[10] 이 가르키는 것은 해당 경우의 수는 계단의 수의 조건을 만족한다라는 것이다.
그렇다라는 것은 dp[11] 은 앞에 혹은 뒤에다가 경우의 수를 추가할 수 있다.

그러면
9876543210 여기에다가 뒤나 혹은 앞에다가 추가할 수 있는 것이다.

생각 해보니까 , 뒤에다가 숫자 그냥 3개를 집어넣을 수가 있구나,
98...
99....
이렇게도 되고
8이면
89... 는 안되고
88 , 87... 은 된다.
연속된 숫자가 반복되는 경우에는 3가지의 경우
만일 나와 1차이가 나는 경우의 수가 반복되는 경우는 2가지의 경우가 존재한다.

솔직히 감이 전혀 안잡히기 때문에 , 답을 한번 봐야 할 것 같다.

또 개같은 문제를 잘 못 읽었었다.
0 차이나면 안되고 , 무조건 1이 차이가 나야 한다.

-- 해맸던 점
처음에 dp를 long 으로 선언을 안했고,
다 맞았는데 , 이상하게 다 틀렸습니다 나와서 혹시 몰라서
result += dp[N][i][1023] % MOD 를 -> result = (result + dp[N][i][1023]) % MOD 로 바꾸었 더니 맞았음 , 연산 순서때문에 틀렸었던 것 같고
그 다음에 dp 연산을 진행할 때 MOD를 지웠었는데 , 그것 때문에 , 또 틀렸었다 , 이외에 것들은 맞았햐
 */
public class Main {
    public static int N;
    public static final int MOD = 1_000_000_000;
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(input.readLine());

        long[][][]  dp = new long[N + 1][10][1 << 10]; // 10 자리 수를 비트마스킹을 통해서 , 표현할 것이기 때문에 , 1 << 10 으로 크기를 맞춰줌

        for(int i = 1; i < 10; i++){ // 0 으로 시작하는 수는 없으니까 , 0으로 시작하는 것은 없애기위해서 i == 1 부터 시작함
            dp[1][i][1 << i] = 1; // 1자리 수 면서 i 로 끝나는 수이고 , 비트마스킹 1 << i 를 포함하고 있는 경우의 수는 1자리에서는 당연히 1이다.
        }

//        System.out.println(1 << 10);

        for(int i = 2; i <= N; i++){
            for(int j = 0; j < 10; j++){
                for(int k = 0; k < 1 << 10; k++){
                    int bit = k | (1 << j); // j 가 포함된 수로 감
                    if(j == 0){ // 끝자리가 9인 경우나 0 인 경우는 하나 밖에 더 못들어옴
                        dp[i][j][bit] = (dp[i][j][bit] + dp[i - 1][j + 1][k]) % MOD;
                    } else if(j == 9){
                        dp[i][j][bit] = (dp[i][j][bit] + dp[i - 1][j - 1][k]) % MOD;
                    } else{
                        dp[i][j][bit] = (dp[i][j][bit] + dp[i - 1][j - 1][k] + dp[i - 1][j + 1][k]) % MOD;
                    }
                }
            }
        }

        long result = 0;
//        long check = 0;
//        for(int i = 1; i <= 40; i++){
//            for(int j = 0; j < 10; j++){
//                check += dp[i][j][1023];
//            }
//        }
        for(int i = 0; i < 10; i++){
            result = (result + dp[N][i][1023]) % MOD;
        }
//        System.out.println(check);
        System.out.println(result);
    }
}