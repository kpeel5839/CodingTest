import java.util.*;
import java.io.*;

// 1715 : 카드 정렬하기

/*
-- 전제 조건
정렬을 하는데 , A , B 의 카드 묶음이 있다고 했을 떄 ,
A + B 번의 비교가 있다 , 근데 이것은 약간 추상적으로 묶음을 합치려면 각 묶음에 있는 숫자들을 다 파악하고 , 합쳐야 한다 , 그렇다는 것은 그것은 비교 연산으로 칠 수 있다라는 것이다.
즉 비교연산이라고 할 지 언정 , 그냥 인식하고 , 합치는 과정을 비교과정이라고 칭한 것 같다.

그래서 묶음의 합치는 순서에 따라서 , 비교 횟수가 달라진다.
그래서 , 이 경우에 , 묶음이 주어졌을 때 , 최소의 비교횟수를 구해라.
-- 틀 설계
일단 2차원 리스트로 계산하면 안된다.

그렇게 하면 시간 초과가 될 것 , 왜냐하면 배열로만 만들어도 10만 * 10만 == 100 억 이기 때문이다.
숫자 묶음의 크기가 많이 작다 , 이것과 연관이 있지 않을까?

(10 + 20) + (30 + 40) = 100
(10 + 40) + (50 + 20) = 120

즉 합치는 순서에 따라서 결과는 달라지게 된다.
여기서 값이 작으려면 조건이 하나이다.
어떤 수와 어떤 수를 더했을 때 , 그 값이 너무 크면 안된다.

10 20 30 40 으로 한번 순서대로 진행해서 한 묶음으로 만든다고 가정해보자.
(10 + 20) + (30 + 30) + (60 + 40) = 190

그냥 다른 순서대로 진행해보자.
(10 + 30) + (40 + 20) + (60 + 40) = 200
진짜 다르다. 결국 여기서 알 수 있는 것은 합을 구할 때,

순서대로 정렬한다음에 한번 더 해보자.

역시나 이 방법은 너무 말이 안되게 쉽다.
그리고 무엇보다 반례로 3 , 3 , 4 , 5 가 있을 떄
3 , 3 합치고 6 , 4 를 합치고 10 , 5 를 합치는 것보다.
3 , 3 합치고 4 , 5 를 합치고 9 , 6 을 합치는 것이 좋다.
딱 봐도 1이 더 낮음

3 , 3 , 3 , 3 도
(3 + 3) + (6 + 3) + (9 + 3) = 27
(3 + 3) + (3 + 3) + (6 + 6) = 24

역시나 내가 처음에 예측했던 것처럼 , 합이 오름차순이 되어야 한다.
즉 합들이 가장 작은 순서대로 쭉 합쳐가야 한다.

이 문제의 가정을 인용하면 , 합이 작은 경우부터 차례대로 계산하게 되면 ,
절대로 최소 값이 나올 수 밖에 없음 , 근데 그럴려면 전체 부분합의 계산을 인지하고 있어야 한다.

이런 방법은 어떨까? PriorityQueue 를 유지하면서 , 계속 2개씩 뽑고 더하고 다시 넣고
를 반복하는 것임 , 그러다가 하나만 남았을 경우 끝낸다.

그러면서 계속 더하는 과정에서 생긴 cost들을 다 더해서 저장해놨다고 출력하면 가능하지 않을까?
 */
public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(input.readLine());
        PriorityQueue<Long> queue = new PriorityQueue<>();


        for(int i = 0; i < N; i++){
            queue.add(Long.parseLong(input.readLine()));
        }

        long ans = 0;

        while(!(queue.size() == 1)){ // 1이 되면 바로 끝냄
            long a = queue.poll();
            long b = queue.poll();

            ans += a + b;
            queue.add(a + b);
        }

        System.out.println(ans);
    }
}