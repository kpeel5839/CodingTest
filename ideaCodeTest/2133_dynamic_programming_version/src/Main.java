import java.util.*;
import java.io.*;

// 2133 : 타일 채우기
/*
--전제조건
3 * N 크기의 벽을 2 * 1 , 1 * 2 의 타일로 채우는 경우의 수를 구하자
N 은 최대 30이다.
N이 2라면 3이 나온다. 이럴때는 3 * 2 에다가 2 * 1 , 1 * 2를 채워넣은 경우의 수를 구해야하는 것
(r , c) 즉 3 이 행 길이이고 n 이 열 길이이다.
-- 틀 설계
역시나 dp는 약하다... 답을 봄
일단 크기가 홀수로 들어오게 되면 무조건 0을 반환한다. 왜냐하면 홀수로 들어오게 되면 그것은 절대 2 * 1 , 1 * 2 벽돌로 채울 수가 없기 때문이다.
그러면 이제 일단 dp[0] .... dp[n] 이라고 가정해보자
그러면 dp[0]은 3 * 0인 경우이다 , 근데 이 경우를 다 채우는 경우가 1가지만 존재한다고 가정해보자
그리고 dp[1]은 홀수니까 0으로 가정하자
그러면 이제 dp[2] 의 경우 즉 3 * 2 경우에는 블록이 채워지는 경우가 3가지가 존재하고 , 그것을 A , B , C라고 가정하자
그 다음에 3 * 4 를 채우는 과정을 생각해보자 , 쉽게 생각하면 그냥 3 * 2 , 3 * 2 로 나누는 경우가 존재한다
그러면 dp[2] * dp[2] = 9에다가 항상 특별한 모양이 2가지가 존재해 dp[2] * dp[2] + 2이다.
그러면 이제 dp[6] 의 경우를 생각해보자 이 경우에는 case가 3 * 2, 3 * 4로 나누는 경우와 3 * 4 , 3 * 2로 나누는 경우가 존재한다.
그러면 일단 3 * 2 , 3 * 4 로 나눈 경우를 생각해보면 당연히 dp[2] * dp[4] 이다 그럼 이제 3 * 4 , 3 * 2 의 경우가 존재한다.
이 경우에 당연히 3 * 2 , 3 * 4의 경우와 겹칠 수 밖에 없다. 이 경우에 겹치지 않으려면 3 * 4의 특별한 모양만을 이용해야한다.
3 * 4 도 결국 A , B , C 그룹의 블록으로 이루어져있다 그렇기 때문에 3 * 2 , 3 * 4 를 구하면 이미 중복되는 경우인 것이니
3 * 2 * (3 * 4의 특별한 경우) == 2 를 구하면은 3 * 2 , 3 * 4 의 경우에서도 중복되지 않는 경우를 구할 수가 있음
그러면 마지막으로 3 * 6 에서의 또 특별한 경우인 2가지를 더해주면 된다
3 * 4 , 3 * 2 에서의 특별한 3 * 4가 특별한 경우인 것은 이미 3 * 2 , 3 * 4 즉 dp[2] * dp[4] 할 떄 구해졌음
그래서 결론은 다 3 * 4 도 A , B , C 를 쓰는 것이니 3 * 2 , 3 * 2 가 된 것이고 특별한 경우 2가지를 제외하면
그래서 dp[2] * 2 를 하는 것이다 , 왜냐하면 dp[2] * dp[4] - (dp[4] - 2 * dp[2]) 이런식으로 이해하면 쉽다라는 것이다
dp[2] * dp[4]의 경우에서 dp[4]의 경우가 특별한 모양이 아니면 이미 앞에서 한 중복된 형태일테이니 특별한 경우만 빼서 계산하는 것이다.
dp[8] 같은 경우에도 3 * 6 , 3 * 2 를 계산하고 , (3 * 4) * (3 * 4) , (3 * 2) * (3 * 6) 이라는 것을 알 수 있다 이것들이 다 특별한 경우 2가지를 제외한
A, B , C 블록을 이용한 경우이기 때문에 가능한 연산들인 것이다 , 그래서 당연히 3 * 4 , 3 * 4로 나눴을 때도 뒤에 3 * 4가 특별한 경우가 아니라면 , 무조건 중복일 수밖에 없으니 dp[4] * 2 , (3 * 2) * (3 * 6)도 똑같은 맥락인 것이다.
그래서 결국 점화식은 dp[n - 2] * dp[2] + dp[n - 4] * 2 + dp[n - 6] * 2 .... + dp[n - (n - 2)] * 2 가 될 수밖에 없는 것이다
그래서 설계는 일단 dp[2]에다가 3을 넣어놓고
n 까지 짝수로 올라가도록 for문을 돌리고
dp[i] 를 구할 때에는 for(int i = i - 2; i >= 2 i -= 2) 까지 진행한다.
그러면서 이제 dp[n]을 출력하면 된다.
 */
public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(input.readLine());
        int[] dp = new int[n + 1];

        if(n % 2 != 0 || n == 0){
            System.out.println(0);
            return;
        }
        dp[2] = 3;
        for(int i = 4; i <= n; i+= 2){
            int value = dp[i - 2] * dp[2];
            for(int j = i - 4; j >= 2; j -= 2){
                value += dp[j] * 2;
            }
            dp[i] = value + 2;
        }
        System.out.println(dp[n]);
    }
}
