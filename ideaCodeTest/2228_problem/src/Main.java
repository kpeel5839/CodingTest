import java.util.*;
import java.io.*;

// 2228 : 구간 나누기

/*
-- 전제조건
N 개의 수로 이루어진 1차원 배열이 존재한다 , 이 배열에서 M 개의 구간을 선택해서 구간에 속한 수들의 총 합이 최대가 되도록 하려고한다.

각 구간들은 한 개 이상의 연속된 수들로 이루어져 있어야 하고
인접해서 골라서는 안된다.
그리고 정확히 M개의 구간이 있어야 한다.

N개의 수들이 주어졌을 때 , 답을 구하는 프로그램을 작성하시오.
-- 틀설계
N 은 100 개의 수로 이루어져 있고,
구간의 개수가 정해져있다.

이것도 그냥 Top-Down 으로 찾아낼 수 있을 것 같긴한데..
dp 로 지금까지 선택한 구간의 수가 있을 때
현재로서 더 선택해서 얻을 수 있는 구간의 수
이렇게 하면 되지 않을까?

일단 N과 구간의 개수 M을 받자.
그 다음에 dfs 로 해결해나갈 것인데
dp로는 이런식으로 구성할 것이다.
dp[인덱스][선택한 구간의 수] 로 진행을 하고
여기서 이제 뒤로 진행하면서 , 선택해 나가는 것이다.
근데 구간을 꼭 맞게 선택해야 하니까 조건으로 구간을 맞지 않게 선택했을 때에는 그냥 return 해 버린다.

if(dp[select][idx] != MIN) return dp[select][idx]; 을 하였을 때 , 시간초과가 나는 반례
100 40
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
이러한 반례를 통해서 , 그래도 맞았다라는 것을 증명해냈음
알고보니까 이러한 것이였음 , 만일 select 를 다 하지 못하고 끝나게 되면 MIN 값을 반환하게 됨,
MIN 값을 반환한 것은 만약 다 선택하지 못하게 되었을 때 , 이 값을 의미없게 만들기 위함이였음
그리고 만일 select == M 을 다하였을 때 최종적으로 return 되는 수는 0
즉 다 골랐으면 이제 거기서 0 을 반환하면서 지금까지 골랐던 것을 재귀적으로 반환하면서 dp[select][idx] 를 채워나가는 것이였다.

근데 , 여기서 문제가 있었다.
모든 원소가 0인 경우에는?
그러면 MIN 값을 반환하게 되면 결과적으로 dp 값에 변화가 없다
그 의미는 방문처리가 되지 않는다라는 것이다.
이전에 내가 그렇게 했었던 이유는 전혀 0 만으로 이루어질 것이라는 점을 고려하지 않았던 점이었다.

0만으로 이루어져 있다면 select 다 하지 못하였을 때 , 얘가 의미없는 수라는 것을 밝히기 위해서 MIN 값을 반환하는 것이였는데
dp 값들이 다 MIN 이라면 처음에 dp[select][idx] = dfs(idx + 1 , select); 여기서 , 결국 MIN 값을 받게 될 것이다.
그렇게 된다면? 당연하게도 MIN 값만으로 유지될 것이다.
이래서 dp[select][idx] 값도 계속 MIN 으로 유지되기에 , visited 처리가 당연하게도 되지 않을 것이고
그렇게 되면 당연하게 시간 초과가 날 것이다.
내가 이전에 간과하고 있던 점은 0이라는 점과 , 그러한 반례로 인해서 발생하는 visited 처리가 되지 않는 것을 고려하지 않았다라는 것이다.

결국 여기서 포인트는 그것이였다.
dp 기본 값과 , 다 선택하지 못하였을 때 , 반환되는 말도 안되게 작은 수 , 즉 틀렸다고 반환하는 수가 같으면 안되는 것이다.

그렇게 바꾸니까 맞았음 , 역시나 내 생각대로,
visited 배열을 유지할 필요가 없었던 것이였음

내가 이전에 틀렸었던 이유는
dfs(idx + 1 , select) 즉 , 이 곳은 구간에 포함시키지 않는 경우와
구간에 포함시키는 경우들을 넘겼었어야 했다.
근데 구간에 포함시키는 경우는 다양한 경우가 존재하지만 (길이 1 , 2 , 3 ... n)
하지만 포함시키지 않는 경우는 하나만 존재한다.

그렇기 때문에 , loop 에다가 넣었으면 안됐었다. 왜냐하면 선택하지 않는 경우는 본인을 선택하지 않는 경우 하나이니까 , 만약 loop 에다가 넣어버리면 다른 idx 들도 선택하지 않고 , 넘어간다라는 의미가 되어버림
그렇기 때문에 혼선이 존재했었던 것이고
본인을 선택하지 않았을 때 , 가질 수 있는 최대 값을 일단은 저장해놓고서 거기에서의 최대 값을 돌려받고
그 다음에 , 구간을 선택하였을 때 돌려받을 수 있는 최대값들을 계속해서 비교한 뒤 dp[select][idx] 를 현재로서 할 수 있는 최선의 값으로 유지한다.

그리고 해당 재귀호출이 return 될 때까지 이전노드가 본인을 방문한다거나 그것은 있을 수도 없다 , 왜냐하면 idx 는 증가하는 방향으로만 흘러가고 , 본인 이전 호출은 본인이 끝난 뒤에야 다시 진행이 될 수가 있으니까
그렇기 때문에 뭐 dp 값을 먼저 담아놔서 , dp[select][idx] = dfs(i + 1 , select); 이런식으로 해서 맞은 것도 아니고,
그냥 내가 이전에 했던 방법들이 처음에는 본인만 포함안시키는 경우를 진행해야 하는데 , 그렇지 않았고 , 모든 원소들이 0인 경우를 고려하지 않아서,
dp[select][idx] == MIN 이 실제로 방문하고 최소값을 구하기 전까지 진행 되었을 때 , 다 선택하지 못해서 , 그냥 지나가는 경우도
방문처리가 되도록 하여야 한다.

시간초과가 나는 이유는 다른게 아니라 , 해당 지점에서는 불가능하다라는 것을 dp[select][idx] 를 통해서 알려야 하는데 , 똑같이 실패해서 MIN 값이니까 해당 지점이 실패하는지 안하는지 모르고
그냥 아직 안왔다갔구나 , 그래서 계속 탐색해봐야지 하면서 진행하는 거싱다 , 그렇기 때문에 , 구간의 개수가 40 개가 있어야 할때에는 개 오래 걸리지만 100 2 에다가 0 100개 주면 빨리 끝나는 이유가
구간의 개수가 2개이면 분기도 적게 되고 , 해당 칸이 끝나는 칸인지 안 끝나는 칸인지 알게 뭐야 하고 돌아보면 되기 때문이다.

-- 결론
내가 맞추지 못했던 이유는
첫째 , select 가 다 되는 순간 즉 다 고르는 순간 0을 반환해서 끝났다라는 것을 알려야 했음
둘째 , 실패하였을 때 , 반환하는 값과 , dp 배열의 기본값이 같아서 , 원소가 다 0인 경우 , 해당 지점에 이 select 로 가면 성공 못한다라는 것을 알려야 하는데 , 그러지 못했음
(구간의 수가 많을 수록 분기도 많이되고 , 해당 칸을 이 select 로 왔을 때 실패할 경우의 수가 많음 , 그렇기에 이 구간에 이 select 로 오면 실패한다는 것을 알려주는 것이 더더욱 중요함)
셋째 , 본인을 선택하지 않는 경우는 본인 자신만이 결정해야 하는데 , 반복문에 넣게 되면서 다른 지점까지 넘어가는 그러한 로직이 되어버렸었음

이렇게 3가지를 고치니까 정상적으로 문제를 해결 할 수 있었음
 */
public class Main {
    // 이전에 내가 작성했던 limit 은 있으면 안됨 , 왜냐하면 구간의 사이즈는 각자 다를 수도 있기 떄문이다.
    public static int N , M , MIN = -1_000_000_000;
    public static int[][] dp;
    public static int[] arr;
    public static int dfs(int idx , int select){

        if(select == M) return 0;
        if(N <= idx) return MIN * 2;
        // 생각해보니까 , MIN 값을 반환한다. 그리고 arr 값이 다 만약에 0이다.
        // 그러면 개 클떄 안끝나지 않을까?
        if(dp[select][idx] != MIN) return dp[select][idx];

        /*
        내가 이전에 했던 방식은 Math.max(dp[select][idx] , Math.max(dfs(i + 1 , select) , dfs(i + 2 , select + 1) + sum); 이런 방식이였음
        근데 이렇게 하면 문제가 dfs(i + 1 , select) 는 해당 칸은 그냥 넘어가는 것인데 , 이것은 본인 칸에서만 진행을 해야 한다.
        왜냐하면 , 당연하게도 , 다른 칸에서 넘어가는 것을 허용해서는 안되기 떄문이다 , 내가 못 해결하고 있던 부분이 이 부분이 아니였을까?
         */

        dp[select][idx] = dfs(idx + 1 , select);

        int sum = 0;
        // 구간을 선택하지 않고 , 넘기는 경우도 존재해야 함
        for(int i = idx; i < N; i++){
            // 구간을 선택할 때의 더할 값을 계속 구해나감
            sum += arr[i];
            // 구간을 선택하지 않는 경우와 , 선택하는 경우로 나뉨
            dp[select][idx] = Math.max(dp[select][idx] , dfs(i + 2 , select + 1) + sum);
        }

        return dp[select][idx];
    }
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(input.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        dp = new int[M][N];
        arr = new int[N];

        for(int i = 0; i < M; i++) Arrays.fill(dp[i] , MIN);

        for(int i = 0; i < N; i++){
            arr[i] = Integer.parseInt(input.readLine());
        }

        System.out.println(dfs(0 , 0));
    }
}

