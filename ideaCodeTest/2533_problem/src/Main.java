import java.time.LocalDateTime;
import java.util.*;
import java.io.*;
import java.util.stream.Collectors;

// 2533 : 사회망 서비스 SNS

/*
-- 전제조건
얼리어답터는 , 주변에 아이디어가 전파되기 이전에 이미 그 정보를 알고 있어서 주변에다가 아이디어를 전파하는 사람을 의미한다.
그래서 트리가 주어질 때 , 얼리어답터의 최소의 수를 구하여

-- 틀설계
트리의 정점의 개수는 최대 100만개가 주어진다.
일단 트리를 준 이유는 분명하게 , 사이클이 존재하는 경우 , 혹은 해당 정점까지 경로가 여러개인 경우를 배제해야 하는 경우의 문제라는 것을 의미한다.
그래서 이 문제를 어떻게 dynamic 하게 빠르게 풀 수 있을까라는 고민을 해보자.

일단 처음에 해본 생각은 이전 노드가 선택되지 않았다라면 , 선택을 하는 방법을 선택하였다.
하지만 , 이것은 아니라는 생각을 하게 되었음.

왜냐하면 O - X - X - O 이런식의 트리가 있다고 했을 때 , 연속으로 X 가 두개이지만 양쪽에 O 가 존재한다는 사실이 있음
그러면 여기서 고려해야 할 사항은 , 이전 노드가 연결이 되어있냐라는 것이고 , 이것을 어떻게 고려할 수 있을까..

그럼 본인의 이후 상황만을 고려하는 것은 어떨까?
이것도 dp[2][N] 으로 만들고,
0 은 본인이 이미 다른 노드와 연결이 되어있다라는 가정하에 진행
1 은 본인이 다른 노드와 연결이 되어있지 않다라는 가정하에 진행

이런식으로 dp를 구성해보면 어떨까?
즉 위의 경우는 이런식으로 표현이 가능하다.
이전 노드가 얼리어답터냐 , 아니냐로 표현이 가능하다.

-- 결과
이 문제를 풀긴 했지만
답을 보았고 , 거기서 힌트를 얻긴 하였는데 , 직접 코드를 작성하였음

하지만 무엇인가 찝찝하다.
일단 첫째로 INF 를 썼을 때 틀렸던 이유를 짚어보자.

INF 를 썼을 때 , 연산을 수행한뒤에 dp 값들은 이러하다. 사실 여기서 이미 문제를 발견하였음
[100000000, 4, 2, 1, 1, 0, 0, 0, 0, 0]
[100000000, 100000000, 100000002, 100000001, 100000001, 1, 1, 1, 1, 1]

정상적일 때
[0, 3, 1, 1, 1, 0, 0, 0, 0, 0]
[0, 0, 2, 1, 1, 1, 1, 1, 1, 1]

이래서 결과값이 다르게 나왔었고,
그 다음에 , 또 의문점인 부분은 왜 이전 노드가 얼리어답터가 아니라면 현재 노드는 , 무조건 얼리어답터이여야 할까?
그 다음 노드가 얼리어답터이여도 되잖아 , 그리고 이전 노드가 얼리어답터가 아니라는 것은 이전 노드와 연결이 되어있었다라는 것인데
여기서 말하는 가정에도 ,이 부분은 솔직히 정확하게 이해가 가지 않는다.

만약에 이렇게 되어있었다라면?
O - X - X - O - XXXX
이렇게 되어있었다라고 하면?

2번째 것은 선택이 되지 않았을 테이고,
3번째 것은 여기서의 조건이라면 무조건 선택되어야 한다.
근데 , 선택되면 ? 여기서는 개 손해본다.
이런 경우는??

아.....
이 조건을 안읽었었음..
이 조건을 읽었었음 혼자서도 풀 수 있었을 텐데..
처음에 이 트리를 봤을 때도 혹시 dp 아닐까 했었는데
아쉽다.


"사회망 서비스에 속한 사람들은 얼리 아답터이거나 얼리 아답터가 아니다. 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다."

문제에 이렇게 적혀있었네
이러면 이게 맞음 ..

이전 노드가 얼리 어답터가 아니라면 현재 해당 정점이 얼리어답터가 되지 않으면 , 이전노드는 모든 친구들이 얼리어답터가 될 수 없음

그래서 위와 같은 선택을 할 수있는 것이다.

-- 결론
문제를 잘 읽어야 한다 , 그래서 이 문제의 조건에 따라서 이전 노드가 얼리어답터라면 , 현재 노드는 얼리어답터가 맞을수도 아닐 수도 있다 (선택지가 2개)
하지만 , 이전 노드가 얼리어답터가 아니라면 , 해당 노드는 무조건 선택되어야 한다 , 왜냐하면 부모노드의 모든 친구들이 얼리어답터여야 하니까

그 다음에 INF 로 초기화하는 바람에 이전이 얼리어답터가 아닌 경우 , 즉 경우가 하나라서 내가 변수를 따로 선언하지 않은 부분들에 대해서는
INF 에다가 값이 더해져서 원하는 결과가 나오지 않았음.

그래서 이 문제는 dp[0][i] , dp[1][i] 를 기준으로 , dp[1][i] 는 무조건 적으로 선택되어야 하는 구간
즉 , 이전 노드가 얼리어답터가 아닌 경우였는데 해당 정점에서의 최대값을 이전 노드가 얼리어답터인 경우의 최솟값을 반환하면 문제가 있는 것이니까
dp[1][i] 값을 받게 된다,

또 이전에 선택한 경우는 그 두가지의 경우를 모두 내포하는 dp[0][i] 에서 , 더 나은 값 혹은 같은 값을 반환 받을 수 있는 것이다.

즉 dp를 2개의 분기로 나눈 이유는 , 이전에가 얼리어답터가 아닌 경우에는 선택이 강제되니 , 현재 노드를 선택하지 않은 경우의 dp 값을 반환하면 안되는 것이기에 그렇게 한 것이다.
즉 dp[0][i] == 선택했을 수도 , 안 했을수도 , 선택을 강요하지 않는 상황 dp[1][i] == 선택을 무조건 해야 하는 상황(이전 노드가 얼리어답터 x)
 */
public class Main {
    public static int[][] dp;
    public static List<ArrayList<Integer>> graph = new ArrayList<>();
    public static int N;
//    public static final int INF = 100_000_000;

    public static int dfs(int p , int c , int pre){
        /*
        아얘 이러한 가정에서 시작하자.
        일단 당연하게 p로 다시 못가고
        이전에 선택되지 않았으면 무조건 적으로 선택되어야 한다고 가정해보자.
         */

        if(dp[pre][c] != 0) return dp[pre][c];

        // leap node 에 대한 처리를 안해주었음
        boolean leap = true;

        int res1 = 0;
        int res2 = 0;

        for(Integer next : graph.get(c)){
            if(next != p){ // 가려는 노드가 부모가 아니라면
                leap = false;
                // 가는데 , 여기서 이전 노드가 얼리어답터가 아닌 경우였더라면 , 본인이 무조건 선택되어야 하고
                // 만일 얼리어답터였다면 , 선택해도 되고 , 선택하지 않아도 된다.
                if(pre == 0){ // 이전이 얼리어답터 o
                    res1 += dfs(c , next , 0); // 현재 것을 선택하는 경우
                    res2 += dfs(c , next , 1); // 현재 것을 선택하지 않는 경우
                }
               else{ // 이전이 얼리어답터 x
                    dp[pre][c] += dfs(c , next , 0);
                }
            }
        }

        if(!leap) {
            if (pre == 1) dp[pre][c] += 1;
            else {
                dp[pre][c] = Math.min(res1 + 1, res2);
            }
        }

        else{
            if(pre == 0) dp[pre][c] = 0;
            else dp[pre][c] = 1;
        }

        return dp[pre][c];
    }
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        N = Integer.parseInt(input.readLine());

        dp = new int[2][N + 1];

        for(int i = 0; i <= N; i++){
            graph.add(new ArrayList<>());
        }

//        for(int i = 0; i < 2; i++){
//            Arrays.fill(dp[i] , INF);
//        }

        for(int i = 0; i < N - 1; i++){
            st = new StringTokenizer(input.readLine());

            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            graph.get(a).add(b);
            graph.get(b).add(a);
        }

        System.out.println(dfs(-1 , 1 , 0));
//        for(int i = 0; i < 2; i++) System.out.println(Arrays.toString(dp[i]));
    }
}
