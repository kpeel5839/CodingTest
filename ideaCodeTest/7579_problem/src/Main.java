import java.util.*;
import java.io.*;

// 7579 : 앱
/*
--전제조건
우리는 앱을 사용하면서 화면에 보이는 실행 중인 앱은 하나뿐이지만 보이지 않는 상태로 많은 앱들이 활성화 되어있다.
앱들이 활성화가 되어있다는 것은 화면에 보이지 않더라도 메인 메모리에 직전의 상태가 로드 되어있다는 것을 의미한다.
현재 실행 중이 아니더라도 이렇게 메모리에 남겨두는 이유는 나중에 사용자가 다시 이 앱을 불러올 때 직전의 상태를 메인 메모리로부터 읽어 들여오기 위해서이다.
근데 이제 스마트폰의 한계가 있다보니 너무 많은 앱들이 활성화 되어있으면 메모리가 부족하다
그렇기 때문에 임의로 정해서 앱들을 비활성화 시킨다.(메모리에서 삭제)
메모리 부족상황에서 활성화 되어 있는 앱들을 무작위로 필요한 메모리만큼 비활성화 하는 것은 좋은 방법이 아니다.
그래서 효율적으로 메모리에서 제거하여서 비활성화로 만들어놓아야한다.
현재 n개의 앱 A1 .... An 이 활성화 되어있다고 가정했을 때 이들 앱 Ai는 각각 Mi 바이트만큼의 메모리를 사용하고 있다.
또 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우 추가적으로 들어가는 비용을 수치화 한 것을 Ci라고 하자
그러니까 Ai 는 Mi , Ci를 가진 것이다 Mi = 메모리를 차지하는 용량 , Ci = 다시 활성화 시킬 때의 오버헤드
이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여 , 추가로 M 바이트의 메모리가 필요하다고 했을 때
현재 활성화 되어 있는 앱 A1 .... An 중에서 몇개를 비활성화 하여 M 바이트 이상의 메모리를 추가로 확보해야 하는 것
이제 이 경우에서 M바이트를 확보하면서 가장 적은 Ci 의 합을 가지는 방법을 찾아야한다.
M 은 무조건 총합보다 작거나 같다 (그래야지 확보가 가능하니까) 근데 같을 수도 있다는 것은 모두를 비활성화 할 수도 있다는 것
그래서 결국 n이 주어지고 m이 주어졌을 때 m만큼 공간을 확보하면서 , Ci 의 합이 가장 적은 방법의 Ci의 합을 출력하라
--틀설계
 */
public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

    }
}
