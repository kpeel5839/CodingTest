import java.util.*;
import java.io.*;

// 9527 : 1의 개수 세기

/*
-- 전제조건
수 A, B 가 주어졌을 때 ,
해당 값 사이에 있는 값들을 이진수로 표현하였을 때 ,
1의 개수들의 합을 출력하시오.
-- 틀설계
2 10
3 11
4 100
5 101
6 110
7 111
8 1000
9 1001
10 1010
11 1011
12 1100
13 1101
14 1110
15 1111
16 10000

이런식으로 구성이 된다...

2 부터 1의 개수의 누적합을 구해보자.

이런식으로 진행이 된다.
2 3 4 5 6 7  8  9  10 11 12
1 3 4 6 8 11 12 14 16 19 21

혹은 각 1의 개수를 적어서 한번 특징을 파악해보자.
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
1 2 1 2 2 3 1 2 2  3  2  3  3  4  1

일단 확실한 것은 어쩔 수 없이 2의 배수마다 개수는 1로 초기화가 진행된다...
즉 무조건 적으로 2의 배수 단위로 1의 개수가 초기화 된다라는 것이고 특정한 규칙을 가지고 , 그 사이의 값들에서 1의개수가 정해진다.
2 ^ n - 1 <= x < 2 ^ (n) 의 1의 개수는 최대 log n이다.

이 점을 이용해서 할 수 있지 않을까?

0 ~ 1 = 1
2 ~ 3 = 3
4 ~ 7 = 8
8 ~ 15 = 20

음..
일단 단편적으로 생각했을 때에는
1이 하나인 경우와 , 다 차있는 경우
그것은 2 ^ n 과 2 ^ (n + 1) - 1 인 경우밖에 없다.
이 사이의 수들은 각각의 2의 개수를 가지는데 , 확실한 것은 절대적으로 2개 이상이라는 것이다.
물론 자릿수가 2자리 이상일 때 부터

그리고 이진수는 당연하게도 해당 자릿수부터 숫자가 모두 채워졌을 경우
다시 한자리로 업그레이드 된다.

사실 2 ^ n 이 무조건 1자리 인것 또한 그렇다 2 ^ n - 1 이 1로 전부 차있기 때문에 당연한 결과이다.
그러면 이것을 어떻게 계산할 수 있을까
1 자리 일때 1 = 1
2 자리 일때 1 + 2 = 3
3 자리 일때 1 + 2 + 2 + 3 = 8
4 자리 일때 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 = 20
5 자리 일때 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 + 2 + 3 + 3 + 4 + 3 + 4 + 4 + 5 = 48
6 자리 일때 112

6자리일 때 구해보자.
16 + 48 * 2 = 112

5자리 일 때 한번 해보자.
10000 = 1
10001 = 2
10010 = 2
10011 = 3
10100 = 2
10101 = 3
10110 = 3
10111 = 4
11000 = 2
11001 = 3
11010 = 3
11011 = 4
11100 = 3
11101 = 4
11110 = 4
11111 = 5

2 , 5 , 12 , 23 어떠한 느낌이 있을까..

38 다음은?

규칙을 찾아냈다.
이진수 찍어놓고서 가만히 들여다봤는데
첫번째 자릿수 부터 계속 자릿수가 올라갈때마다.
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111

이런식으로 진행되었던 것에서 본인의 끝자리만 추가되서 진행되는 것을 볼 수 있음
그래서 0 ~ 1 을 먼저 구하고
그러면 1 이나온다.
그러면 1 + 2 를 해주면 되고
또 4까지는 끝 자리가 1 로 고정되고 2자리는 또 이전껏을 반복한다. 구분해서보면 이러하다
1 00
1 01
1 10
1 11
즉 앞에거에서 1을 더한 것을 한번 더 진행재무녀 된다라는 것이다 그러면
1 + 2 + 2 + 3 이런식으로 가능하다.
그러면 또 4자리이면?

1 000
1 001
1 010
1 011
1 100
1 101
1 110
1 111

이런식으로 반복되고 이걸 식으로 표현하면
1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 이런식으로 표현할 수 있다.

앞의 수에다가 1를 더한 것들을 더한다...
그러면 2 ^ (n - 2) + 이전 값 * 2

이런식으로 구할 수 있게 된다.

이렇게 되는 이유는
앞에 1이 붙고 현재까지 반복해온 가짓수로 또 앞에 1이 붙고 반복되기 때문이다.
그래서 현재까지 지나온 가능한 경우의 수 2 ^ (n - 1) 의 2분의 1 에다가 1을 더해야 하기 떄문에 결국
2 ^ (n - 2) 가 되고 거기다가 이전 수 * 2 를 하면 되는 것이다.

결국 답을 보았다.

일단 확실하게 , 2 ^ (n - 1) + 2 * number[i - 1] 은 맞았었다.
그니까 내가 구한 방법은 2 ~ 3
혹은 0 ~ 1
뭐 2 ^ n <= x < 2 ^ (n + 1) 구간의 1의 숫자들을 구한 것이다.
하지만 내가 했던 방법보다 , 전체 개수를 구하는 방법을 선택했었어야 했다.

그래서 , 전체 개수를 구하는 방법은 굉장히 간단했다 , 2 ^ (n - 2) + 2 * number[i - 1] 을 하던 나의 방법에서
2 ^ (n - 1) + 2 * number[i - 1] 을 하는 것이였다
이것을 수식으로 변경하면 1 << i + 2 * number[i - 1] 이다.
저렇게 수식이 변경 되는 이유는

예를 들어서 0 ~ 1 의 경우는
1이다.
그리고 2 ~ 3 의 경우는
0
1
10
11
이렇게 되어서 총 4이다.
그리고 쭉쭉
0
1
10
11
100
101
110
111 총 12이다.

이런식으로 볼 수 있듯이 , 일단 1이 추가되면서 , 앞자리를 제외한 수들이 다시 반복되기에 1의 개수는 일단 * 2 가 되어야 하고
그 다음에는 현재 3이라고 했을 떄 , 8개가 추가되니까 거기다가 그거의 반은 4 를 곱해주면 된다.
즉 2 ^ (n - 1)이다.
저렇게 전체적으로 놓고 보면 , 이해가 굉장히 쉽게 간다.

즉 이렇게 나오는 이유는 일단 똑같은 수들이 다시 2번 반복이 되니까 , 지금까지 1 의 개수 * 2 이고 , 이전 경우의 수들에다가 1을 다 더해주기 떄문에
이전 경우의 수를 + 해주어야 한다 , 근데 이전 경우의 수를 구하는 방법은 2 ^ (n - 1) 이다.
그래서 이걸 0부터 시작하는 프로그래밍 상에서 보면 2 ^ i 가 되는 것이다.
그래서 이런식으로 유지할 수가 있고,

이제 26이라는 이러한 숫자가 들어왔을 때 , 0 ~ 26 까지 1의 개수가 몇개일까를 생각해볼 수 있다.
일단 , 0 ~ 15까지 진행했을 때의 수를 알 수가 있다.
그것은 그냥 number[4] 이다. 즉 5번째 자리를 빼는 것이다.

이렇게 0 ~ 15 까지 경우의 수를 빼고 나면 이제 26 - 15 를 해준다.
그러면 11이 된다 , 이제 여기서 순서대로 계속 구해준다.
1들만 계속 제거 해주다 보면 0이 되니까 , 그런 식으로 쭉 구할 수 있다.

예를 들어서
9를 한번 봐보자.
일단 , 9까지 1의 개수가 몇개일까?
쉽다 12 + 1 + 2 = 15
15이다.

이렇게 나오나 한번 봐보자.
1001

이다. 여기서 0 ~ 0111 까지 1의 개수는 몇일까?
우리가 구해놓은 12로 쉽게 구할 수 있다.

그래서 1001 - 0111 을 하게 되면
0010 이 된다.
그러면 그러면 0 ~ 01 까지 경우의 수를 구하면 된다.
그러면 1 개
그리고 0001 이 된다.
그 다음에 또 구하면 , 이제 1까지의 1의 개수는 1이다.

그래서 이런식으로 계속 나오는 수들을 더해서 저장해놓으면
9까지의 1의 개수를 구할 수 있는 것이다.

그래서 a = 2 , b = 9 라고 할 떄
2 ~ 9 까지의 1의 개수는 당연하게도
9까지의 개수 - 1까지의 개수일 것이다.
왜냐하면 2도 포함한 것이니까

즉 식의 의미를 이런 식으로 귀결시킬 수 있다.
b까지의 1의 개수 - (a - 1 까지의 1의 개수)
그러면 당연하게도 a 이전의 1의 개수들은 빠지고 b까지의 1의 개수를 세니까 끝낼 수 있다.

아니다..
일단 누적 1의 개수를 구하는 방법은 앞에서 설명했던 것이 정확하다.
0
1
10
11
100
101
110
111

이렇게 있을 때 , 이제 4자리수에 들어간다고 하면 앞에서 했던 것들이 반복이 될 것이고
1의 개수들은 이전의 경우의 수만큼 추가되기에
2 ^ (n - 1) + 2 * number[n - 1] 이다. (n은 현재 자릿수)

-- 해맸던 점
1 << i 이거 1 long 으로 설정안해서 자꾸 틀렸음
자료형때문에 계속 틀렸음

-- 결론
일단 Test case 로
0 부터 모든 자리가 1인 수까지의 개수를 구하는 공식인
2 ^ (n - 1) + bit[n - 1] * 2 이것을 증명하면
0
1
10
11
100
101
110
111

이런식으로 존재하고,
현재까지 이렇게 8가지의 경우의 수가 존재한다.

이제 4번째 비트 즉 , 15 까지의 1의 개수를 구하면 일단
1 + (이전 경우의 수들) 이라는 것을 확실하게 알 수 있다.
그래서 그렇다라는 것은 일단 , 1의 개수를 1차적으로 이전 1의 개수 * 2 로 1차적으로 구할 수 있고
2차적으로는 추가된 1의 개수를 추가하는 것이다.
이전의 경우에서 1이 추가된다 그렇기 때문에 2 ^ n 이 현재의 경우의 수고
2 ^ n - 1 이 이전 경우의 수이다.
그래서 2 ^ (n - 1) + (bit[n - 1] * 2) 이런식으로 표현할 수 있다.

그래서 이렇게 모든 수가 1인 경우의 수들을 구할 수 있고,
이제 그렇지 않은 수의 1의 개수들을 구해보면
일단 26이라고 가정해보자. 숫자를
그러면 이런식으로 된다.
11010 이런식으로 된다.
그래서 일단 0 번째 부터 4번째 비트 중
4번쨰 비트를 먼저 없애자.

그 떄 일단 0 ~ 15 의 1의 개수는 우리가 이미 알고 있다.
0 ~ 1 (0) 1
0 ~ 3 (1) 4
0 ~ 7 (2) 12
0 ~ 15 (3) 32
그래서 bit[3]을 더해준다.
이것은 bit[i - 1] 로 변환해줄 수 있다.

그리고 나머지 16 ~ 26이 남아있다 , 얘내들의 1의 개수를 세주지 못하였다 그래서 일단 얘내들이 공통적으로 가지고 있는 , 맨 앞자리를 제거하면?
0 ~ 10이 된다 , 그리고 제거하면서 1의 개수를 센것이니까 11 개를 더해준다 이것은 (x + 1 - (1L << i)) 로 구해줄 수 있다. (32 + 11)

그리고 1010 을 다시 구하면
0 ~ 7 의 개수를 구할 수 있고 그것은 bit[2] 이다. (bit[i - 1]) (43 + 12 + 3)

그래서 8 ~ 10 의 수들이 남아있고 확실히 있는 1인 맨 앞 비트를 제거한다.
0 ~ 2 의 수들만 남았기에 10 을 진행해준다.
그러면 얘는 또 bit[0] 이다. (58 + 1 + 1)
그래서 2 ~ 2 로 구할 수 있고 , 그래서 맨 앞에 1을 제거해주면
이제 0 ~ 0 이기에 끝난다.
결과 : 60

첫째자리는 처음 메소드를 호출하면서 제거해주어 , bit[i - 1] 연산에서 index out of exception 을 막을 수 있다.

이런식으로 진행하면서 1의 개수들의 합을 구할 수 있다 , 누적합을 이용한것이기에 답을 구할 때에는 getCount(B) - getCount(A - 1) 하면 된다.

입력
1 26

출력 결과 (위에서 한 것들을 각각 출력한 것임 , bit 값과 , 나머지 수들을 각각 출력)
32 11
12 3
1 1
60
 */
public class Main {
    public static long A , B;
    public static long[] number;
    public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(input.readLine());

        A = Long.parseLong(st.nextToken());
        B = Long.parseLong(st.nextToken());

        // 64 면 64도 포함이기에 배열에 포함시킬 수 있도록 + 1 을 시키고 , Math.floor 를 하였음 , 그러면 중간값이 들어오더라도 올림도 가능하고 , 혹은 그냥 정수값이 나오더라도 , 올림이 가능하다.
        number = new long[(int)Math.floor(Math.log(B) / Math.log(2) + 1)];

        number[0] = 1;
        for(int i = 1; i < number.length; i++){
            // Math.pow(2 , i - 1) 에서 Math.pow(2 , i) 로 바꾸면 해당 bit 까지의 1의 개수가 나온다.
            number[i] = (1L << i) + (number[i - 1] * 2);
        }

        System.out.println(getCount(B) - getCount(A - 1));
    }
    public static long getCount(long x){
        long ans = x & 1; // 0번째 비트가 1인 경우 비트를 음수를 찾기 때문에 , 인덱스 에러가 난다. 그래서 이런식으로 해서 , 1이면 ans 에다가 1을 아니면 0을 삽입한다.

        /*
        여기서 이렇게 해준다.
        일단 1이 있는 자리를 보고
        0 ~ 해당 자리 까지 값을 구하는 것이다.
        그러면 이제 26 이라고 했을 때 , 16 ~ 26 까지의 숫자는 구하지 못했다.
        하지만 여기서 그냥 맨 끝자리만 놓고 보았을 때 , 나중에 이 16 ~ 26의 숫자들의 1의 개수를 세기 위해서는 이 숫자들의 개수만큼 1의 개수를 추가해주면 된다.
        그 이유는 일단 지금 0 ~ 15 의 1의 개수를 구했는데 16 ~ 26을 못구해서 문제인 것이다 , 근데 이제 끝 비트 , 즉 4번째 비트는 무조건 1이니깐 일단 1을 개수만큼 추가해주는 것이다
        (나머지 비트에 1이 있을 수도 있지만 이것은 나중에 계속 연산을 하면서 구하는 것이다.)
        그리고 이거 1을 없애면 각 숫자들은 0 ~ 10 까지 숫자이다 (아까 1을 빼면서 16 ~ 26의 4번째 비트인 1이 16을 의미하기에 16을 빼준 것)
        그래서 여기서 또 하면 3번째 비트를 뺼 수 있고 , 8 ~ 10 까지를 또 못구한다 그래서 또 앞의 1의 자리를 빼주면 0 2 까지 구한다

        이런식으로 일단 맨 앞에 있는 1의 자릿값 까지의 1의 개수들을 다 세준다음에 , 그 다음에 남은 수들의 맨 앞에 1을 제거해주어서 , 순차적으로 구해주는 것이다.
        즉 느낌이 어떤식이냐면
        1011
        1100
        1101

        이런식으로 있으면
        일단 15까지의 1의 개수들을 구해서 더하고
        여기서 1들만 빼주는 거임
        그러면
        100
        101
        그러면 여기서 나머지 숫자들의 앞에 자리를 빼면서 1의 개수들을 세었기 떄문에 , 또 셀 필요가 없고 거기서 바로 연산을 진행하면 된다.
        그러면 순차적으로
        또 맨 앞자리 구하고

        1 빼주면
        00
        01

        또 구하고 1 빼주면
        0
        1

        또 이러면 마지막에 그냥 1개를 세주면 된다.

        지금 이런식으로 구해가는 것을 식으로 표현한것이다.
         */

        // 앞에서 1을 먼저 세주고 , 없애서 , 여기서 절대로 마지막에 1이 남을 일이 없음
        // 왜냐하면 맨 앞의 0 ~ 1의 자릿수 값 - 1 까지 개수 더해준다음에 , 그 수를 빼면서 그 숫자들의 개수를 더해주기 때문이다.
        for(int i = number.length - 1; i > 0; i--){ // number.length - 1 로 한 이유는 number.length 는 현재 수를 이진수로 표현했을 때 길이를 나타내는데 , 실제로 1 << 0 이 가르키는 것은 첫번쨰 ㄱ밧이다.
            // 그렇기 떄문에 맨 마지막 값을 가르키기 위해서는 number.length - 1 이다 , 즉 number.length 로 하면 쓸데없는 짓인 것이다.
            // 이제 여기서 연산을 시작해줄 것이다.
            if((x & (1L << i)) > 0L){
                System.out.println(number[i - 1] + " " + (x + 1 - (1L << i)));
                ans += number[i - 1] + (x + 1 - (1L << i));
                x -= (1L << i);
            }
        }

        return ans;
    }
}
